// vnm_plot Benchmark - Window Implementation

#include "benchmark_window.h"

#include <glatter/glatter.h>
#include <glm/gtc/matrix_transform.hpp>

#include <algorithm>
#include <iostream>

namespace vnm::benchmark {

Benchmark_window::Benchmark_window(const Benchmark_config& config, QWidget* parent)
    : QOpenGLWidget(parent)
    , config_(config)
    , generator_([&config]() {
        Brownian_generator::Config gen_config;
        gen_config.seed = config.seed;
        gen_config.volatility = config.volatility;
        gen_config.initial_price = 100.0;
        gen_config.time_step = 1.0 / config.rate;
        return gen_config;
    }())
{
    setWindowTitle("vnm_plot Benchmark");
    resize(1200, 720);

    // Create buffers based on data type
    if (config_.data_type == "Trades") {
        trade_buffer_ = std::make_unique<Ring_buffer<Trade_sample>>(config_.ring_capacity);
        trade_source_ = std::make_unique<Benchmark_data_source<Trade_sample>>(*trade_buffer_);
    } else {
        bar_buffer_ = std::make_unique<Ring_buffer<Bar_sample>>(config_.ring_capacity);
        bar_source_ = std::make_unique<Benchmark_data_source<Bar_sample>>(*bar_buffer_);
    }

    // Connect timers
    connect(&render_timer_, &QTimer::timeout, this, &Benchmark_window::on_render_timer);
    connect(&benchmark_timer_, &QTimer::timeout, this, &Benchmark_window::on_benchmark_timeout);
}

Benchmark_window::~Benchmark_window()
{
    stop_generator_thread();

    makeCurrent();
    if (primitives_) {
        primitives_->cleanup_gl_resources();
    }
    if (series_renderer_) {
        series_renderer_->cleanup_gl_resources();
    }
    doneCurrent();
}

void Benchmark_window::stop_generator_thread()
{
    if (generator_thread_.joinable()) {
        stop_generator_.store(true);
        generator_thread_.join();
    }
}

void Benchmark_window::generator_thread_func()
{
    // Time-based generation for accurate sample rate
    const double samples_per_second = config_.rate;
    const double ns_per_sample = 1e9 / samples_per_second;

    auto start_time = std::chrono::steady_clock::now();

    while (!stop_generator_.load()) {
        auto now = std::chrono::steady_clock::now();
        double elapsed_ns = std::chrono::duration<double, std::nano>(now - start_time).count();

        // Calculate how many samples should have been generated by now
        double target_samples = elapsed_ns / ns_per_sample;
        std::size_t current_count = samples_generated_.load();

        // Generate samples to catch up
        while (current_count < static_cast<std::size_t>(target_samples) && !stop_generator_.load()) {
            if (config_.data_type == "Trades") {
                trade_buffer_->push(generator_.next_trade());
            } else {
                bar_buffer_->push(generator_.next_bar());
            }
            ++samples_generated_;
            ++current_count;
        }

        // Sleep briefly to avoid busy-waiting (1ms)
        std::this_thread::sleep_for(std::chrono::microseconds(100));
    }
}

void Benchmark_window::initializeGL()
{
    if (!vnm::plot::init_gl()) {
        std::cerr << "ERROR: Failed to initialize glatter\n";
        return;
    }

    // Validate OpenGL version
    GLint major = 0, minor = 0;
    glGetIntegerv(GL_MAJOR_VERSION, &major);
    glGetIntegerv(GL_MINOR_VERSION, &minor);
    if (!config_.quiet) {
        std::cout << "OpenGL " << major << "." << minor << " initialized\n";
    }

    if (major < 4 || (major == 4 && minor < 3)) {
        std::cerr << "WARNING: OpenGL " << major << "." << minor
                  << " detected, but vnm_plot requires OpenGL 4.3+\n";
    }

    // Initialize asset loader
    asset_loader_ = std::make_unique<vnm::plot::Asset_loader>();
    asset_loader_->set_log_callback([](const std::string& msg) {
        std::cerr << "asset_loader: " << msg << "\n";
    });
    vnm::plot::init_embedded_assets(*asset_loader_);

    // Initialize renderers
    primitives_ = std::make_unique<vnm::plot::Primitive_renderer>();
    series_renderer_ = std::make_unique<vnm::plot::Series_renderer>();
    chrome_renderer_ = std::make_unique<vnm::plot::Chrome_renderer>();

    if (!primitives_->initialize(*asset_loader_)) {
        std::cerr << "ERROR: Failed to initialize primitive renderer\n";
        return;
    }
    series_renderer_->initialize(*asset_loader_);

    // Configure rendering
    render_config_.dark_mode = true;
    render_config_.show_text = false;  // Disable text for benchmark simplicity
    render_config_.snap_lines_to_pixels = false;
    render_config_.line_width_px = 1.5;
    render_config_.profiler = &profiler_;  // Wire up profiler for vnm_plot internal scopes

    // Set up series
    setup_series();

    gl_initialized_ = true;

    // Record start time
    started_at_ = std::chrono::system_clock::now();

    // Start generator thread (separate from UI thread)
    stop_generator_.store(false);
    generator_thread_ = std::thread(&Benchmark_window::generator_thread_func, this);

    // Start render timer and benchmark duration timer
    render_timer_.start(16);    // ~60Hz rendering
    benchmark_timer_.setSingleShot(true);
    benchmark_timer_.start(static_cast<int>(config_.duration_seconds * 1000));
}

void Benchmark_window::resizeGL(int w, int h)
{
    glViewport(0, 0, w, h);
}

void Benchmark_window::paintGL()
{
    if (!gl_initialized_) {
        glClearColor(0.15f, 0.15f, 0.15f, 1.0f);
        glClear(GL_COLOR_BUFFER_BIT);
        return;
    }

    // Use framebuffer size for HiDPI support
    const int fb_w = static_cast<int>(width() * devicePixelRatioF());
    const int fb_h = static_cast<int>(height() * devicePixelRatioF());

    glViewport(0, 0, fb_w, fb_h);
    glEnable(GL_MULTISAMPLE);
    glEnable(GL_BLEND);
    glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);

    const auto palette = vnm::plot::Color_palette::for_theme(render_config_.dark_mode);
    glClearColor(palette.background.r, palette.background.g, palette.background.b, palette.background.a);
    glClear(GL_COLOR_BUFFER_BIT);

    // Update view range based on data
    update_view_range();

    // Build layout
    vnm::plot::frame_layout_result_t layout;
    layout.usable_width = fb_w;
    layout.usable_height = fb_h;
    layout.v_bar_width = 0.0;
    layout.h_bar_height = 0.0;

    // Build frame context
    vnm::plot::frame_context_t ctx{
        layout,
        v_min_,
        v_max_,
        v_min_,  // preview_v0
        v_max_,  // preview_v1
        t_min_,
        t_max_,
        t_min_,  // t_available_min
        t_max_,  // t_available_max
        fb_w,
        fb_h,
        glm::ortho(0.f, float(fb_w), float(fb_h), 0.f, -1.f, 1.f),
        12.0,    // adjusted_font_px
        14.0,    // base_label_height_px
        0.0,     // adjusted_reserved_height
        0.0,     // adjusted_preview_height
        false,   // show_info
        &render_config_
    };

    // Render - vnm_plot internal scopes are captured by profiler automatically
    chrome_renderer_->render_grid_and_backgrounds(ctx, *primitives_);
    series_renderer_->render(ctx, series_map_);
    chrome_renderer_->render_preview_overlay(ctx, *primitives_);
    primitives_->flush_rects(ctx.pmv);
}

void Benchmark_window::on_render_timer()
{
    update();  // Schedule repaint
}

void Benchmark_window::on_benchmark_timeout()
{
    stop_generator_thread();
    render_timer_.stop();
    emit benchmark_finished();
}

void Benchmark_window::setup_series()
{
    auto series = std::make_shared<vnm::plot::series_data_t>();
    series->id = 1;
    series->enabled = true;
    series->color = glm::vec4(0.2f, 0.7f, 0.9f, 1.0f);

    if (config_.data_type == "Trades") {
        // Use DOTS style for point data (trades)
        series->style = vnm::plot::Display_style::DOTS;
        series->shader_set = {
            "shaders/function_sample.vert",
            "shaders/plot_dot.geom",
            "shaders/plot_dot.frag"
        };
        series->data_source = std::shared_ptr<vnm::plot::Data_source>(
            trade_source_.get(), [](vnm::plot::Data_source*) {});
        series->access = make_trade_access_policy();
    } else {
        // Use AREA style for range data (bars) to exercise OHLC range
        series->style = vnm::plot::Display_style::AREA;
        series->shader_set = {
            "shaders/function_sample.vert",
            "shaders/plot_area.geom",
            "shaders/plot_area.frag"
        };
        series->data_source = std::shared_ptr<vnm::plot::Data_source>(
            bar_source_.get(), [](vnm::plot::Data_source*) {});
        series->access = make_bar_access_policy();
    }

    series_map_[series->id] = series;
}

void Benchmark_window::update_view_range()
{
    // Get current data range from source
    vnm::plot::Data_source* source = nullptr;
    if (config_.data_type == "Trades") {
        source = trade_source_.get();
    } else {
        source = bar_source_.get();
    }

    if (!source) return;

    auto result = source->try_snapshot();
    if (result.status != vnm::plot::snapshot_result_t::Status::OK) {
        return;
    }

    const auto& snapshot = result.snapshot;
    if (snapshot.count == 0) return;

    // Get time range from first and last samples
    const auto* first_bytes = static_cast<const char*>(snapshot.data);
    const auto* last_bytes = first_bytes + (snapshot.count - 1) * snapshot.stride;

    double t_first = 0.0;
    double t_last = 0.0;

    if (config_.data_type == "Trades") {
        t_first = reinterpret_cast<const Trade_sample*>(first_bytes)->timestamp;
        t_last = reinterpret_cast<const Trade_sample*>(last_bytes)->timestamp;
    } else {
        t_first = reinterpret_cast<const Bar_sample*>(first_bytes)->timestamp;
        t_last = reinterpret_cast<const Bar_sample*>(last_bytes)->timestamp;
    }

    // Show last 10 seconds of data (sliding window)
    const double window_size = 10.0;
    t_max_ = t_last;
    t_min_ = std::max(t_first, t_last - window_size);

    // Update value range
    if (source->has_value_range()) {
        auto [lo, hi] = source->value_range();
        // Add 10% padding
        float padding = (hi - lo) * 0.1f;
        if (padding < 0.01f) padding = 1.0f;  // Minimum padding
        v_min_ = lo - padding;
        v_max_ = hi + padding;
    }
}

}  // namespace vnm::benchmark
