// vnm_plot Benchmark - Window Implementation

#include "benchmark_window.h"

#include <glatter/glatter.h>
#include <glm/gtc/matrix_transform.hpp>

#include <algorithm>
#include <cstdio>
#include <cstring>
#include <iostream>

namespace vnm::benchmark {

namespace {

std::string format_benchmark_timestamp(double ts, double /*range*/)
{
    // Format timestamp as seconds with 1 decimal.
    char buf[32];
    std::snprintf(buf, sizeof(buf), "%.1f", ts);
    return buf;
}

}  // namespace

Benchmark_window::Benchmark_window(const Benchmark_config& config, QWidget* parent)

:
    QOpenGLWidget(parent),
    m_config(config),
    m_generator([&config]() {
        Brownian_generator::Config gen_config;
        gen_config.seed = config.seed;
        gen_config.volatility = config.volatility;
        gen_config.initial_price = 100.0;
        gen_config.time_step = 1.0 / config.rate;
        return gen_config;
    }())
{
    setWindowTitle("vnm_plot Benchmark");
    resize(1200, 720);

    // Create buffers based on data type
    if (m_config.data_type == "Trades") {
        m_trade_buffer = std::make_unique<Ring_buffer<Trade_sample>>(m_config.ring_capacity);
        m_trade_source = std::make_unique<Benchmark_data_source<Trade_sample>>(*m_trade_buffer);
    }
    else {
        m_bar_buffer = std::make_unique<Ring_buffer<Bar_sample>>(m_config.ring_capacity);
        m_bar_source = std::make_unique<Benchmark_data_source<Bar_sample>>(*m_bar_buffer);
    }

    // Connect timers
    connect(&m_render_timer, &QTimer::timeout, this, &Benchmark_window::on_render_timer);
    connect(&m_benchmark_timer, &QTimer::timeout, this, &Benchmark_window::on_benchmark_timeout);
}

Benchmark_window::~Benchmark_window()
{
    stop_generator_thread();

    makeCurrent();
    if (m_primitives) {
        m_primitives->cleanup_gl_resources();
    }
    if (m_series_renderer) {
        m_series_renderer->cleanup_gl_resources();
    }
#if defined(VNM_PLOT_ENABLE_TEXT)
    vnm::plot::Font_renderer::cleanup_thread_resources();
#endif
    doneCurrent();
}

void Benchmark_window::stop_generator_thread()
{
    if (m_generator_thread.joinable()) {
        m_stop_generator.store(true);
        m_generator_thread.join();
    }
}

void Benchmark_window::generator_thread_func()
{
    // Time-based generation for accurate sample rate
    const double samples_per_second = m_config.rate;
    const double ns_per_sample = 1e9 / samples_per_second;

    auto start_time = std::chrono::steady_clock::now();

    while (!m_stop_generator.load()) {
        auto now = std::chrono::steady_clock::now();
        double elapsed_ns = std::chrono::duration<double, std::nano>(now - start_time).count();

        // Calculate how many samples should have been generated by now
        double target_samples = elapsed_ns / ns_per_sample;
        std::size_t current_count = m_samples_generated.load();

        // Generate samples to catch up
        while (current_count < static_cast<std::size_t>(target_samples) && !m_stop_generator.load()) {
            if (m_config.data_type == "Trades") {
                m_trade_buffer->push(m_generator.next_trade());
            }
            else {
                m_bar_buffer->push(m_generator.next_bar());
            }
            ++m_samples_generated;
            ++current_count;
        }

        // Sleep briefly to avoid busy-waiting (1ms)
        std::this_thread::sleep_for(std::chrono::microseconds(100));
    }
}

void Benchmark_window::initializeGL()
{
    if (!vnm::plot::init_gl()) {
        std::cerr << "ERROR: Failed to initialize glatter\n";
        return;
    }

    // Validate OpenGL version
    GLint major = 0, minor = 0;
    glGetIntegerv(GL_MAJOR_VERSION, &major);
    glGetIntegerv(GL_MINOR_VERSION, &minor);
    if (!m_config.quiet) {
        std::cout << "OpenGL " << major << "." << minor << " initialized\n";
    }

    if (major < 4 || (major == 4 && minor < 3)) {
        std::cerr << "WARNING: OpenGL " << major << "." << minor
                  << " detected, but vnm_plot requires OpenGL 4.3+\n";
    }

    // Initialize asset loader
    m_asset_loader = std::make_unique<vnm::plot::Asset_loader>();
    m_asset_loader->set_log_callback([](const std::string& msg) {
        std::cerr << "asset_loader: " << msg << "\n";
    });
    vnm::plot::init_embedded_assets(*m_asset_loader);

    // Initialize renderers
    m_primitives = std::make_unique<vnm::plot::Primitive_renderer>();
    m_series_renderer = std::make_unique<vnm::plot::Series_renderer>();
    m_chrome_renderer = std::make_unique<vnm::plot::Chrome_renderer>();

    if (!m_primitives->initialize(*m_asset_loader)) {
        std::cerr << "ERROR: Failed to initialize primitive renderer\n";
        return;
    }
    m_series_renderer->initialize(*m_asset_loader);

    // Initialize font and text renderer
#if defined(VNM_PLOT_ENABLE_TEXT)
    const int font_px = static_cast<int>(std::round(m_adjusted_font_px));
    m_font_renderer.initialize(*m_asset_loader, font_px);
    m_text_renderer = std::make_unique<vnm::plot::Text_renderer>(&m_font_renderer);
#else
    if (m_config.show_text && !m_config.quiet) {
        std::cout << "Text rendering disabled at build time (VNM_PLOT_ENABLE_TEXT=OFF)\n";
    }
#endif

    // Configure rendering
    m_render_config.dark_mode = true;
    m_render_config.show_text =
#if defined(VNM_PLOT_ENABLE_TEXT)
        m_config.show_text;
#else
        false;
#endif
    m_render_config.snap_lines_to_pixels = false;
    m_render_config.line_width_px = 1.5;
    m_render_config.format_timestamp = format_benchmark_timestamp;
    m_render_config.profiler = &m_profiler;  // Wire up profiler for vnm_plot internal scopes

    // Set up series
    setup_series();

    m_gl_initialized = true;

    // Record start time
    m_started_at = std::chrono::system_clock::now();

    // Start generator thread (separate from UI thread)
    m_stop_generator.store(false);
    m_generator_thread = std::thread(&Benchmark_window::generator_thread_func, this);

    // Start render timer and benchmark duration timer
    m_render_timer.start(16);    // ~60Hz rendering
    m_benchmark_timer.setSingleShot(true);
    m_benchmark_timer.start(static_cast<int>(m_config.duration_seconds * 1000));
}

void Benchmark_window::resizeGL(int w, int h)
{
    glViewport(0, 0, w, h);
}

void Benchmark_window::paintGL()
{
    if (!m_gl_initialized) {
        glClearColor(0.15f, 0.15f, 0.15f, 1.0f);
        glClear(GL_COLOR_BUFFER_BIT);
        return;
    }

    VNM_PLOT_PROFILE_SCOPE(&m_profiler, "renderer");
    VNM_PLOT_PROFILE_SCOPE(&m_profiler, "renderer.frame");

    // Use framebuffer size for HiDPI support
    const int fb_w = static_cast<int>(width() * devicePixelRatioF());
    const int fb_h = static_cast<int>(height() * devicePixelRatioF());

    glViewport(0, 0, fb_w, fb_h);
    glEnable(GL_MULTISAMPLE);
    glEnable(GL_BLEND);
    glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);

    const auto palette = vnm::plot::Color_palette::for_theme(m_render_config.dark_mode);
    glClearColor(palette.background.r, palette.background.g, palette.background.b, palette.background.a);
    glClear(GL_COLOR_BUFFER_BIT);

    // Update view range based on data
    update_view_range();

    // Calculate layout dimensions
    const double adjusted_reserved_height = m_base_label_height_px + m_adjusted_preview_height;
    const double usable_width = fb_w - m_vbar_width_pixels;
    const double usable_height = fb_h - adjusted_reserved_height;

    // Use layout calculator for label positions
    vnm::plot::Layout_calculator::parameters_t layout_params;
    layout_params.v_min = m_v_min;
    layout_params.v_max = m_v_max;
    layout_params.t_min = m_t_min;
    layout_params.t_max = m_t_max;
    layout_params.usable_width = usable_width;
    layout_params.usable_height = usable_height;
    layout_params.vbar_width = m_vbar_width_pixels;
    layout_params.label_visible_height = usable_height + m_adjusted_preview_height;
    layout_params.adjusted_font_size_in_pixels = m_adjusted_font_px;
#if defined(VNM_PLOT_ENABLE_TEXT)
    layout_params.monospace_char_advance_px = m_font_renderer.monospace_advance_px();
    layout_params.monospace_advance_is_reliable = m_font_renderer.monospace_advance_is_reliable();
    layout_params.measure_text_cache_key = m_font_renderer.text_measure_cache_key();
    layout_params.measure_text_func = [this](const char* text) {
        return m_font_renderer.measure_text_px(text);
    };
#else
    layout_params.monospace_char_advance_px = 0.0f;
    layout_params.monospace_advance_is_reliable = false;
    layout_params.measure_text_cache_key = 0;
    layout_params.measure_text_func = [](const char* text) {
        return static_cast<float>(std::strlen(text));
    };
#endif
    layout_params.h_label_vertical_nudge_factor = vnm::plot::detail::k_h_label_vertical_nudge_px;
    layout_params.format_timestamp_func = format_benchmark_timestamp;
    layout_params.get_required_fixed_digits_func = [](double) { return 2; };
    layout_params.profiler = &m_profiler;

    vnm::plot::layout_cache_key_t cache_key;
    cache_key.v0 = m_v_min;
    cache_key.v1 = m_v_max;
    cache_key.t0 = m_t_min;
    cache_key.t1 = m_t_max;
    cache_key.viewport_size = vnm::plot::Size2i{fb_w, fb_h};
    cache_key.adjusted_reserved_height = adjusted_reserved_height;
    cache_key.adjusted_preview_height = m_adjusted_preview_height;
    cache_key.adjusted_font_size_in_pixels = m_adjusted_font_px;
    cache_key.vbar_width_pixels = m_vbar_width_pixels;
    cache_key.font_metrics_key =
#if defined(VNM_PLOT_ENABLE_TEXT)
        m_font_renderer.text_measure_cache_key();
#else
        0;
#endif

    const vnm::plot::frame_layout_result_t* layout_ptr = m_layout_cache.try_get(cache_key);
    if (!layout_ptr) {
        auto layout_result = m_layout_calc.calculate(layout_params);

        vnm::plot::frame_layout_result_t layout;
        layout.usable_width = usable_width;
        layout.usable_height = usable_height;
        layout.v_bar_width = m_vbar_width_pixels;
        layout.h_bar_height = m_base_label_height_px + 1.0;  // +1 for scissor padding
        layout.max_v_label_text_width = layout_result.max_v_label_text_width;
        layout.v_labels = std::move(layout_result.v_labels);
        layout.h_labels = std::move(layout_result.h_labels);
        layout.v_label_fixed_digits = layout_result.v_label_fixed_digits;
        layout.h_labels_subsecond = layout_result.h_labels_subsecond;
        layout_ptr = &m_layout_cache.store(cache_key, std::move(layout));
    }

    // Build frame context
    vnm::plot::frame_context_t ctx{
        *layout_ptr,
        m_v_min,
        m_v_max,
        m_v_min,  // preview_v0
        m_v_max,  // preview_v1
        m_t_min,
        m_t_max,
        m_t_available_min,  // t_available_min (full data range start)
        m_t_max,            // t_available_max (use current max for preview)
        fb_w,
        fb_h,
        glm::ortho(0.f, float(fb_w), float(fb_h), 0.f, -1.f, 1.f),
        m_adjusted_font_px,
        m_base_label_height_px,
        adjusted_reserved_height,
        m_adjusted_preview_height,
        false,   // show_info
        &m_render_config
    };

    // Render - vnm_plot internal scopes are captured by profiler automatically
    m_chrome_renderer->render_grid_and_backgrounds(ctx, *m_primitives);
    m_series_renderer->render(ctx, m_series_map);
    m_chrome_renderer->render_preview_overlay(ctx, *m_primitives);
    m_primitives->flush_rects(ctx.pmv);

    // Render text labels
#if defined(VNM_PLOT_ENABLE_TEXT)
    if (m_text_renderer && m_render_config.show_text) {
        m_text_renderer->render(ctx, false, false);
    }
#endif
}

void Benchmark_window::on_render_timer()
{
    update();  // Schedule repaint
}

void Benchmark_window::on_benchmark_timeout()
{
    stop_generator_thread();
    m_render_timer.stop();
    emit benchmark_finished();
}

void Benchmark_window::setup_series()
{
    auto series = std::make_shared<vnm::plot::series_data_t>();
    series->id = 1;
    series->enabled = true;
    series->color = glm::vec4(0.2f, 0.7f, 0.9f, 1.0f);

    if (m_config.data_type == "Trades") {
        // Use DOTS style for point data (trades)
        series->style = vnm::plot::Display_style::DOTS;
        series->shader_set = {
            "shaders/function_sample.vert",
            "shaders/plot_dot.geom",
            "shaders/plot_dot.frag"
        };
        series->data_source = std::shared_ptr<vnm::plot::Data_source>(
            m_trade_source.get(), [](vnm::plot::Data_source*) {});
        series->access = make_trade_access_policy();
    }
    else {
        // Use AREA style for range data (bars) to exercise OHLC range
        series->style = vnm::plot::Display_style::AREA;
        series->shader_set = {
            "shaders/function_sample.vert",
            "shaders/plot_area.geom",
            "shaders/plot_area.frag"
        };
        series->data_source = std::shared_ptr<vnm::plot::Data_source>(
            m_bar_source.get(), [](vnm::plot::Data_source*) {});
        series->access = make_bar_access_policy();
    }

    m_series_map[series->id] = series;
}

void Benchmark_window::update_view_range()
{
    // Get current data range from source
    vnm::plot::Data_source* source = nullptr;
    if (m_config.data_type == "Trades") {
        source = m_trade_source.get();
    }
    else {
        source = m_bar_source.get();
    }

    if (!source) {
        return;
    }

    auto result = source->try_snapshot();
    if (result.status != vnm::plot::snapshot_result_t::Status::OK) {
        return;
    }

    const auto& snapshot = result.snapshot;
    if (snapshot.count == 0) {
        return;
    }

    // Get time range from first and last samples
    const auto* first_bytes = static_cast<const char*>(snapshot.data);
    const auto* last_bytes = first_bytes + (snapshot.count - 1) * snapshot.stride;

    double t_first = 0.0;
    double t_last = 0.0;

    if (m_config.data_type == "Trades") {
        t_first = reinterpret_cast<const Trade_sample*>(first_bytes)->timestamp;
        t_last = reinterpret_cast<const Trade_sample*>(last_bytes)->timestamp;
    }
    else {
        t_first = reinterpret_cast<const Bar_sample*>(first_bytes)->timestamp;
        t_last = reinterpret_cast<const Bar_sample*>(last_bytes)->timestamp;
    }

    // Track available time range for preview bar
    m_t_available_min = t_first;

    // Show last 10 seconds of data (sliding window)
    const double window_size = 10.0;
    m_t_max = t_last;
    m_t_min = std::max(t_first, t_last - window_size);

    // Update value range
    if (source->has_value_range()) {
        auto [lo, hi] = source->value_range();
        // Add 10% padding
        float padding = (hi - lo) * 0.1f;
        if (padding < 0.01f) {
            padding = 1.0f;  // Minimum padding
        }
        m_v_min = lo - padding;
        m_v_max = hi + padding;
    }
}

}  // namespace vnm::benchmark
