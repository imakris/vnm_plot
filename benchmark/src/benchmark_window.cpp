// vnm_plot Benchmark - Window Implementation

#include "benchmark_window.h"
#include "benchmark_frame.h"

#include <glatter/glatter.h>
#include <glm/gtc/matrix_transform.hpp>

#include <algorithm>
#include <cstdio>
#include <cstring>
#include <iostream>

namespace vnm::benchmark {

Benchmark_window::Benchmark_window(const Benchmark_config& config, QWidget* parent)

:
    QOpenGLWidget(parent),
    m_config(config),
    m_generator([&config]() {
        Brownian_generator::Config gen_config;
        gen_config.seed = config.seed;
        gen_config.volatility = config.volatility;
        gen_config.initial_price = 100.0;
        gen_config.time_step = 1.0 / config.rate;
        return gen_config;
    }())
{
    setWindowTitle("vnm_plot Benchmark");
    resize(1200, 720);

    // Create buffers based on data type
    if (m_config.data_type == "Trades") {
        m_trade_buffer = std::make_unique<Ring_buffer<Trade_sample>>(m_config.ring_capacity);
        m_trade_buffer->set_profiler(&m_profiler);
        m_trade_source = std::make_unique<Benchmark_data_source<Trade_sample>>(*m_trade_buffer);
    }
    else {
        m_bar_buffer = std::make_unique<Ring_buffer<Bar_sample>>(m_config.ring_capacity);
        m_bar_buffer->set_profiler(&m_profiler);
        m_bar_source = std::make_unique<Benchmark_data_source<Bar_sample>>(*m_bar_buffer);
    }

    // Connect timers
    connect(&m_render_timer, &QTimer::timeout, this, &Benchmark_window::on_render_timer);
    connect(&m_benchmark_timer, &QTimer::timeout, this, &Benchmark_window::on_benchmark_timeout);
}

Benchmark_window::~Benchmark_window()
{
    stop_generator_thread();

    makeCurrent();
    if (m_primitives) {
        m_primitives->cleanup_gl_resources();
    }
    if (m_series_renderer) {
        m_series_renderer->cleanup_gl_resources();
    }
#if defined(VNM_PLOT_ENABLE_TEXT)
    vnm::plot::Font_renderer::cleanup_thread_resources();
#endif
    doneCurrent();
}

void Benchmark_window::stop_generator_thread()
{
    if (m_generator_thread.joinable()) {
        m_stop_generator.store(true);
        m_generator_thread.join();
    }
}

void Benchmark_window::generator_thread_func()
{
    // Time-based generation for accurate sample rate
    const double samples_per_second = m_config.rate;
    const double ns_per_sample = 1e9 / samples_per_second;

    auto start_time = std::chrono::steady_clock::now();

    while (!m_stop_generator.load()) {
        auto now = std::chrono::steady_clock::now();
        double elapsed_ns = std::chrono::duration<double, std::nano>(now - start_time).count();

        // Calculate how many samples should have been generated by now
        double target_samples = elapsed_ns / ns_per_sample;
        std::size_t current_count = m_samples_generated.load();

        // Generate samples to catch up
        while (current_count < static_cast<std::size_t>(target_samples) && !m_stop_generator.load()) {
            if (m_config.data_type == "Trades") {
                m_trade_buffer->push(m_generator.next_trade());
            }
            else {
                m_bar_buffer->push(m_generator.next_bar());
            }
            ++m_samples_generated;
            ++current_count;
        }

        // Sleep briefly to avoid busy-waiting (1ms)
        std::this_thread::sleep_for(std::chrono::microseconds(100));
    }
}

void Benchmark_window::initializeGL()
{
    if (!vnm::plot::init_gl()) {
        std::cerr << "ERROR: Failed to initialize glatter\n";
        return;
    }

    // Validate OpenGL version
    GLint major = 0, minor = 0;
    glGetIntegerv(GL_MAJOR_VERSION, &major);
    glGetIntegerv(GL_MINOR_VERSION, &minor);
    if (!m_config.quiet) {
        std::cout << "OpenGL " << major << "." << minor << " initialized\n";
    }

    if (major < 4 || (major == 4 && minor < 3)) {
        std::cerr << "WARNING: OpenGL " << major << "." << minor
                  << " detected, but vnm_plot requires OpenGL 4.3+\n";
    }

    // Initialize asset loader
    m_asset_loader = std::make_unique<vnm::plot::Asset_loader>();
    m_asset_loader->set_log_callback([](const std::string& msg) {
        std::cerr << "asset_loader: " << msg << "\n";
    });
    vnm::plot::init_embedded_assets(*m_asset_loader);

    // Initialize renderers
    m_primitives = std::make_unique<vnm::plot::Primitive_renderer>();
    m_series_renderer = std::make_unique<vnm::plot::Series_renderer>();
    m_chrome_renderer = std::make_unique<vnm::plot::Chrome_renderer>();

    if (!m_primitives->initialize(*m_asset_loader)) {
        std::cerr << "ERROR: Failed to initialize primitive renderer\n";
        return;
    }
    m_series_renderer->initialize(*m_asset_loader);

    // Initialize font and text renderer
#if defined(VNM_PLOT_ENABLE_TEXT)
    const int font_px = static_cast<int>(std::round(m_adjusted_font_px));
    m_font_renderer.initialize(*m_asset_loader, font_px);
    m_text_renderer = std::make_unique<vnm::plot::Text_renderer>(&m_font_renderer);
#else
    if (m_config.show_text && !m_config.quiet) {
        std::cout << "Text rendering disabled at build time (VNM_PLOT_ENABLE_TEXT=OFF)\n";
    }
#endif

    // Configure rendering
    m_render_config.dark_mode = true;
    m_render_config.show_text =
#if defined(VNM_PLOT_ENABLE_TEXT)
        m_config.show_text;
#else
        false;
#endif
    m_render_config.snap_lines_to_pixels = false;
    m_render_config.line_width_px = 1.5;
    m_render_config.format_timestamp = format_benchmark_timestamp;
    m_render_config.profiler = &m_profiler;  // Wire up profiler for vnm_plot internal scopes

    // Set up series
    setup_series();

    m_gl_initialized = true;

    // Record start time
    m_started_at = std::chrono::system_clock::now();

    // Start generator thread (separate from UI thread)
    m_stop_generator.store(false);
    m_generator_thread = std::thread(&Benchmark_window::generator_thread_func, this);

    // Start render timer and benchmark duration timer
    m_render_timer.start(16);    // ~60Hz rendering
    m_benchmark_timer.setSingleShot(true);
    m_benchmark_timer.start(static_cast<int>(m_config.duration_seconds * 1000));
}

void Benchmark_window::resizeGL(int w, int h)
{
    glViewport(0, 0, w, h);
}

void Benchmark_window::paintGL()
{
    if (!m_gl_initialized) {
        glClearColor(0.15f, 0.15f, 0.15f, 1.0f);
        glClear(GL_COLOR_BUFFER_BIT);
        return;
    }

    // Get data source
    vnm::plot::Data_source* source = nullptr;
    if (m_config.data_type == "Trades") {
        source = m_trade_source.get();
    }
    else {
        source = m_bar_source.get();
    }

    // Set up frame parameters
    Benchmark_frame_params params{
        m_t_min,
        m_t_max,
        m_t_available_min,
        m_v_min,
        m_v_max,
        m_config.data_type,
        m_adjusted_font_px,
        m_base_label_height_px,
        m_adjusted_preview_height,
        m_vbar_width_pixels,
        false,  // skip_gl_calls
        false,  // clear_depth (Qt uses color only)
        [this]() -> std::pair<int, int> {
            // Get framebuffer size for HiDPI support
            int fb_w = static_cast<int>(width() * devicePixelRatioF());
            int fb_h = static_cast<int>(height() * devicePixelRatioF());
            return {fb_w, fb_h};
        },
        nullptr  // bind_framebuffer (not needed for Qt)
    };

    // Set up frame context
    Benchmark_frame_context ctx{
        m_profiler,
        m_render_config,
        m_layout_calc,
        m_layout_cache,
        *m_primitives,
        *m_series_renderer,
        *m_chrome_renderer,
        m_series_map,
        source,
#if defined(VNM_PLOT_ENABLE_TEXT)
        &m_font_renderer,
        m_text_renderer.get()
#endif
    };

    // Render the frame using shared helper
    render_benchmark_frame(params, ctx);
}

void Benchmark_window::on_render_timer()
{
    update();  // Schedule repaint
}

void Benchmark_window::on_benchmark_timeout()
{
    stop_generator_thread();
    m_render_timer.stop();
    emit benchmark_finished();
}

void Benchmark_window::setup_series()
{
    auto series = std::make_shared<vnm::plot::series_data_t>();
    series->id = 1;
    series->enabled = true;
    series->color = glm::vec4(0.2f, 0.7f, 0.9f, 1.0f);

    if (m_config.data_type == "Trades") {
        // Use DOTS style for point data (trades)
        series->style = vnm::plot::Display_style::DOTS;
        series->shader_set = {
            "shaders/function_sample.vert",
            "shaders/plot_dot.geom",
            "shaders/plot_dot.frag"
        };
        series->data_source = std::shared_ptr<vnm::plot::Data_source>(
            m_trade_source.get(), [](vnm::plot::Data_source*) {});
        series->access = make_trade_access_policy();
    }
    else {
        // Use AREA style for range data (bars) to exercise OHLC range
        series->style = vnm::plot::Display_style::AREA;
        series->shader_set = {
            "shaders/function_sample.vert",
            "shaders/plot_area.geom",
            "shaders/plot_area.frag"
        };
        series->data_source = std::shared_ptr<vnm::plot::Data_source>(
            m_bar_source.get(), [](vnm::plot::Data_source*) {});
        series->access = make_bar_access_policy();
    }

    m_series_map[series->id] = series;
}

}  // namespace vnm::benchmark
