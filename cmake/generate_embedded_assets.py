#!/usr/bin/env python3
"""Generate C++ source file with embedded assets (shaders, fonts)."""

import argparse
import os
import sys
from pathlib import Path


def to_c_array(data: bytes, name: str) -> str:
    """Convert binary data to a C++ constexpr array."""
    lines = []
    lines.append(f"constexpr unsigned char {name}[] = {{")

    # Split into lines of 16 bytes each
    for i in range(0, len(data), 16):
        chunk = data[i:i+16]
        hex_bytes = ', '.join(f'0x{b:02x}' for b in chunk)
        lines.append(f"    {hex_bytes},")

    lines.append("};")
    return '\n'.join(lines)


def sanitize_name(path: str) -> str:
    """Convert a file path to a valid C++ identifier."""
    name = Path(path).stem + '_' + Path(path).suffix[1:]
    return name.replace('-', '_').replace('.', '_').replace('/', '_')


def generate_cpp(assets: list, output_path: str):
    """Generate the C++ source file with embedded assets."""

    lines = [
        "// Auto-generated file - do not edit",
        "// Generated by cmake/generate_embedded_assets.py",
        "",
        "#include <vnm_plot/core/asset_loader.h>",
        "",
        "namespace vnm::plot::core {",
        "",
        "namespace {",
        "",
    ]

    # Generate arrays for each asset
    asset_names = []
    for asset_path, asset_name in assets:
        with open(asset_path, 'rb') as f:
            data = f.read()

        var_name = 'k_' + sanitize_name(asset_name)
        asset_names.append((asset_name, var_name, len(data)))

        lines.append(f"// {asset_name} ({len(data)} bytes)")
        lines.append(to_c_array(data, var_name))
        lines.append("")

    lines.append("} // anonymous namespace")
    lines.append("")
    lines.append("void init_embedded_assets()")
    lines.append("{")
    lines.append("    auto& loader = default_asset_loader();")
    lines.append("")

    for asset_name, var_name, size in asset_names:
        lines.append(f"    loader.register_embedded(\"{asset_name}\",")
        lines.append(f"        std::string_view(reinterpret_cast<const char*>({var_name}), sizeof({var_name})));")

    lines.append("}")
    lines.append("")
    lines.append("} // namespace vnm::plot::core")
    lines.append("")

    with open(output_path, 'w') as f:
        f.write('\n'.join(lines))


def main():
    parser = argparse.ArgumentParser(description='Generate embedded assets C++ source')
    parser.add_argument('-o', '--output', required=True, help='Output C++ file path')
    parser.add_argument('assets', nargs='+', help='Asset files to embed (path:name or just path)')

    args = parser.parse_args()

    assets = []
    for asset_spec in args.assets:
        if ':' in asset_spec:
            path, name = asset_spec.split(':', 1)
        else:
            path = asset_spec
            # Default name is relative path from current dir
            name = os.path.basename(path)

        if not os.path.exists(path):
            print(f"Error: Asset file not found: {path}", file=sys.stderr)
            return 1

        assets.append((path, name))

    generate_cpp(assets, args.output)
    print(f"Generated {args.output} with {len(assets)} embedded assets")
    return 0


if __name__ == '__main__':
    sys.exit(main())
