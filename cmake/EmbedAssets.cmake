# EmbedAssets.cmake - Generate C++ source with embedded assets
# Usage:
#   embed_assets(
#       OUTPUT <output_file>
#       NAMESPACE <namespace>
#       ASSETS <file1:name1> <file2:name2> ...
#   )

function(embed_assets)
    cmake_parse_arguments(EMBED "" "OUTPUT;NAMESPACE" "ASSETS" ${ARGN})

    if(NOT EMBED_OUTPUT)
        message(FATAL_ERROR "embed_assets: OUTPUT is required")
    endif()

    if(NOT EMBED_NAMESPACE)
        set(EMBED_NAMESPACE "vnm::plot::core")
    endif()

    # Start generating the file content
    set(_content "// Auto-generated file - do not edit\n")
    string(APPEND _content "// Generated by cmake/EmbedAssets.cmake\n\n")
    string(APPEND _content "#include <vnm_plot/core/asset_loader.h>\n\n")
    string(APPEND _content "namespace ${EMBED_NAMESPACE} {\n\n")
    string(APPEND _content "namespace {\n\n")

    # Track asset information for registration
    set(_asset_info "")

    foreach(_asset ${EMBED_ASSETS})
        # Parse file:name format
        string(FIND "${_asset}" ":" _colon_pos)
        if(_colon_pos EQUAL -1)
            set(_file "${_asset}")
            get_filename_component(_name "${_asset}" NAME)
        else()
            string(SUBSTRING "${_asset}" 0 ${_colon_pos} _file)
            math(EXPR _name_start "${_colon_pos} + 1")
            string(SUBSTRING "${_asset}" ${_name_start} -1 _name)
        endif()

        # Read the file
        if(NOT IS_ABSOLUTE "${_file}")
            set(_file "${CMAKE_CURRENT_SOURCE_DIR}/${_file}")
        endif()

        if(NOT EXISTS "${_file}")
            message(FATAL_ERROR "embed_assets: File not found: ${_file}")
        endif()

        file(READ "${_file}" _data HEX)
        string(LENGTH "${_data}" _hex_len)
        math(EXPR _byte_count "${_hex_len} / 2")

        # Generate C++ variable name from asset name
        string(REGEX REPLACE "[^a-zA-Z0-9]" "_" _var_name "${_name}")
        set(_var_name "k_${_var_name}")

        # Add comment and array declaration
        string(APPEND _content "// ${_name} (${_byte_count} bytes)\n")
        string(APPEND _content "constexpr unsigned char ${_var_name}[] = {\n")

        # Convert hex string to comma-separated bytes
        set(_line "    ")
        set(_line_count 0)
        string(REGEX MATCHALL ".." _hex_bytes "${_data}")

        foreach(_byte ${_hex_bytes})
            string(APPEND _line "0x${_byte}, ")
            math(EXPR _line_count "${_line_count} + 1")
            if(_line_count EQUAL 16)
                string(APPEND _content "${_line}\n")
                set(_line "    ")
                set(_line_count 0)
            endif()
        endforeach()

        # Write remaining bytes
        if(_line_count GREATER 0)
            string(APPEND _content "${_line}\n")
        endif()

        string(APPEND _content "};\n\n")

        # Track for registration
        list(APPEND _asset_info "${_name}|${_var_name}")
    endforeach()

    string(APPEND _content "} // anonymous namespace\n\n")

    # Generate init_embedded_assets function (takes loader by reference to avoid deadlock)
    string(APPEND _content "void init_embedded_assets(Asset_loader& loader)\n")
    string(APPEND _content "{\n")

    foreach(_info ${_asset_info})
        string(REPLACE "|" ";" _parts "${_info}")
        list(GET _parts 0 _name)
        list(GET _parts 1 _var)
        string(APPEND _content "    loader.register_embedded(\"${_name}\",\n")
        string(APPEND _content "        std::string_view(reinterpret_cast<const char*>(${_var}), sizeof(${_var})));\n")
    endforeach()

    string(APPEND _content "}\n\n")
    string(APPEND _content "} // namespace ${EMBED_NAMESPACE}\n")

    # Write to output file
    file(WRITE "${EMBED_OUTPUT}" "${_content}")

    message(STATUS "Generated ${EMBED_OUTPUT} with ${_byte_count} bytes of embedded assets")
endfunction()
